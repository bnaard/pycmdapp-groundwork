{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pycmdlineapp_groundworks \ud83d\udd17 pycmdlineapp_groundworks is an opinionated Documentation Inspired by: https://realpython.com/factory-method-python/","title":"Overview"},{"location":"#welcome-to-pycmdlineapp_groundworks","text":"pycmdlineapp_groundworks is an opinionated Documentation Inspired by: https://realpython.com/factory-method-python/","title":"Welcome to pycmdlineapp_groundworks"},{"location":"changelog/","text":"Changelog \ud83d\udd17 All notable changes to this project are documented in this file. [Unreleased] \ud83d\udd17 Added \ud83d\udd17 Changed \ud83d\udd17 Removed \ud83d\udd17 Fixed \ud83d\udd17 [0.1.0] - 2021-01-25 \ud83d\udd17 Added \ud83d\udd17 default configuration and configuration parsing Changed \ud83d\udd17 Removed \ud83d\udd17 Fixed \ud83d\udd17","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project are documented in this file.","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#added","text":"","title":"Added"},{"location":"changelog/#changed","text":"","title":"Changed"},{"location":"changelog/#removed","text":"","title":"Removed"},{"location":"changelog/#fixed","text":"","title":"Fixed"},{"location":"changelog/#010-2021-01-25","text":"","title":"[0.1.0] - 2021-01-25"},{"location":"changelog/#added_1","text":"default configuration and configuration parsing","title":"Added"},{"location":"changelog/#changed_1","text":"","title":"Changed"},{"location":"changelog/#removed_1","text":"","title":"Removed"},{"location":"changelog/#fixed_1","text":"","title":"Fixed"},{"location":"contributing/","text":"Contributing \ud83d\udd17 We'd be happy to get your contirbution to this project! Issues \ud83d\udd17 description tbd Pull Requests \ud83d\udd17 tbd","title":"Contributing"},{"location":"contributing/#contributing","text":"We'd be happy to get your contirbution to this project!","title":"Contributing"},{"location":"contributing/#issues","text":"description tbd","title":"Issues"},{"location":"contributing/#pull-requests","text":"tbd","title":"Pull Requests"},{"location":"development/","text":"Development \ud83d\udd17 Build Tool \ud83d\udd17 The project's dependencies, build-chain and deployment to PyPI is managed with Python Poetry . Main project information is manged in file pyproject.toml Dependencies to the production are added by poetry add <pypi-package-name> Dependencies only needed for development are added by poetry add --dev <pypi-package-name> Versioning \ud83d\udd17 Versioning is managed also by Python Poetry using SemVer : Major version update: poetry version major (for large releases with completely new feature sets and/or breakting API) Minor version update: poetry version minor (for minor feature additions and/or non-breaking api changes) Patch version update: poetry version patch (for bugfixes, minor documentation updates) Though versioning is managed with Python Poetry , the version definition needs manual update in the following steps and locations: Major/Minor/Patch version update using one of the above poetry version commands Manual update of pycmdlineapp_groundwork/__init__.py:__version__ Manual update of `` Documentation \ud83d\udd17 Documentation is build using mkdocs static page generator with several plugins which allow versioning, integration of docstring comments and deploying to Github pages . The advantages of this approach are greater flexibility in page setup and design, integration of docstring comments and examples and simple local preview. The main plugins are: For great design, search and navigation: mkdocs-material For integration of docstring comments: mkdoc-strings For versioning: mike The Github action described in .github/workflows/docs.yml is based on GitHub Actions for GitHub Pages , which builds and deploys mkdoc page structures and takes care that Github is serving those as is instead of using Jekyll. All productive documentation is hosted on gh-pages -branch of this repository. This is automatically managed and overwritten by the mkdoc -tools mentioned above. So, do not edit manually the gh-pages -branch as all your changes will be overwritten and lost on next documentation auto-build+deploy.","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#build-tool","text":"The project's dependencies, build-chain and deployment to PyPI is managed with Python Poetry . Main project information is manged in file pyproject.toml Dependencies to the production are added by poetry add <pypi-package-name> Dependencies only needed for development are added by poetry add --dev <pypi-package-name>","title":"Build Tool"},{"location":"development/#versioning","text":"Versioning is managed also by Python Poetry using SemVer : Major version update: poetry version major (for large releases with completely new feature sets and/or breakting API) Minor version update: poetry version minor (for minor feature additions and/or non-breaking api changes) Patch version update: poetry version patch (for bugfixes, minor documentation updates) Though versioning is managed with Python Poetry , the version definition needs manual update in the following steps and locations: Major/Minor/Patch version update using one of the above poetry version commands Manual update of pycmdlineapp_groundwork/__init__.py:__version__ Manual update of ``","title":"Versioning"},{"location":"development/#documentation","text":"Documentation is build using mkdocs static page generator with several plugins which allow versioning, integration of docstring comments and deploying to Github pages . The advantages of this approach are greater flexibility in page setup and design, integration of docstring comments and examples and simple local preview. The main plugins are: For great design, search and navigation: mkdocs-material For integration of docstring comments: mkdoc-strings For versioning: mike The Github action described in .github/workflows/docs.yml is based on GitHub Actions for GitHub Pages , which builds and deploys mkdoc page structures and takes care that Github is serving those as is instead of using Jekyll. All productive documentation is hosted on gh-pages -branch of this repository. This is automatically managed and overwritten by the mkdoc -tools mentioned above. So, do not edit manually the gh-pages -branch as all your changes will be overwritten and lost on next documentation auto-build+deploy.","title":"Documentation"},{"location":"install/","text":"","title":"Install"},{"location":"license/","text":"MIT License Copyright (c) 2021 bnaard Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"reference/factory/","text":"Factory Utilities \ud83d\udd17 Collection of object builders to create object based on an enum/Descriptor type. Can be directly used with GenericBuilders or specialized builders or can be derived from to eg. pre-register builders. Inspired by RealPython Examples: >>> class MyMessage ( GenericBuildArtifact ): ... _context = \"\" ... _text = \"\" ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessage1 ( MyMessage ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context >>> class MyMessage2 ( MyMessage ): ... def __init__ ( self , context , number ): ... self . _text = str ( number * 42 ) ... self . _context = context >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () ... message2 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> class MyMessageFactory ( Factory ): ... def __init__ ( self ): ... super () . __init__ () ... self . register_builder ( MyMessageBuilder , MyMessageTypes . message1 , MyMessage1 ) ... self . register_builder ( MyMessageBuilder , MyMessageTypes . message2 , MyMessage2 ) >>> message_provider = MyMessageFactory () >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> message2 = message_provider ( MyMessageTypes . message2 , number = 42 ) >>> print ( message1 ) foobar : johndoe >>> print ( message2 ) foobar : 1764 __call__ ( self , type_descriptor_key = None , * args , ** kwargs ) special \ud83d\udd17 Build and return an object referred to by type_descriptor_key using the builder registered for this object type. Parameters: Name Type Description Default type_descriptor_key Union[pycmdlineapp_groundwork.factory.descriptor.StrDescriptor, pycmdlineapp_groundwork.factory.descriptor.IntDescriptor] The enum-derived descriptor identifying the class-object to be built. None *args Positional arguments passed to the registered object builder. () **kwargs Keyword arguments passed to the registered object builder. {} Returns: Type Description ~TGenericBuildArtifact instance of class type (descendant of GenericBuildArtefact) associated with type_descriptor_key Examples: >>> class MyMessage ( GenericBuildArtifact ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> message_provider = Factory () >>> message_provider . register_builder ( MyMessageBuilder , MyMessageTypes . message1 , MyMessage ) >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> print ( message1 ) foobar : johndoe Source code in pycmdlineapp_groundwork/factory/factory.py def __call__ ( self , type_descriptor_key : Union [ StrDescriptor , IntDescriptor ] = None , * args , ** kwargs ) -> TGenericBuildArtifact : \"\"\"Build and return an object referred to by type_descriptor_key using the builder registered for this object type. Args: type_descriptor_key: The enum-derived descriptor identifying the class-object to be built. *args: Positional arguments passed to the registered object builder. **kwargs: Keyword arguments passed to the registered object builder. Returns: instance of class type (descendant of GenericBuildArtefact) associated with type_descriptor_key Example: ```python >>> class MyMessage(GenericBuildArtifact): ... def __init__(self, context, text): ... self._text= text ... self._context= context ... def __str__(self): ... return f'{self._context}: {self._text}' >>> class MyMessageTypes(IntDescriptor): ... message1= auto() >>> class MyMessageBuilder(GenericBuilder): ... def init_hook(self): ... self.set_fixed_args(context= \"foobar\") >>> message_provider= Factory() >>> message_provider.register_builder(MyMessageBuilder, MyMessageTypes.message1, MyMessage) >>> message1= message_provider(MyMessageTypes.message1, text= \"johndoe\") >>> print(message1) foobar: johndoe ``` \"\"\" if type_descriptor_key is None : if self . _builder_registry == {}: raise ValueError ( f ' { self . __class__ . __name__ } : No build artifacts registered, don \\' t know which builder to use.' ) type_descriptor_key = next ( iter ( self . _builder_registry )) if type_descriptor_key not in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key { type_descriptor_key } not yet registered, don \\' t know which builder to use.' ) return self . _builder_registry [ type_descriptor_key ]( type_descriptor_key , * args , ** kwargs ) register_builder ( self , builder_type , type_descriptor_key = None , artifact_type = None ) \ud83d\udd17 Register a builder, either by giving the builders class, the descriptor and the class type it shall create or by giving an already instantiated builder object. After registering, calling the factory with a descriptor uses the registeredbuilder to build the associated objects. Parameters: Name Type Description Default type_descriptor_key Union[pycmdlineapp_groundwork.factory.descriptor.StrDescriptor, pycmdlineapp_groundwork.factory.descriptor.IntDescriptor] The enum-derived descriptor identifying the class-object to be built. None builder_type Union[Type[~TGenericBuilder], pycmdlineapp_groundwork.factory.builder.GenericBuilder] The builder used to create instances of the artifact type. Must be derived from GenericBuilder. required artifact_type Optional[Type[~TGenericBuildArtifact]] The class type to be built. Must be derived from GenericBuildArtifact. None Examples: >>> class MyMessage ( GenericBuildArtifact ): ... _context = \"\" ... _text = \"\" ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessage1 ( MyMessage ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context >>> class MyMessage2 ( MyMessage ): ... def __init__ ( self , context , number ): ... self . _text = str ( number * 42 ) ... self . _context = context >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () ... message2 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> message_provider = Factory () >>> message1_builder = MyMessageBuilder ( MyMessageTypes . message1 , MyMessage1 ) >>> message2_builder = MyMessageBuilder ( MyMessageTypes . message2 , MyMessage2 ) >>> message_provider . register_builder ( message1_builder ) >>> message_provider . register_builder ( message2_builder ) >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> message2 = message_provider ( MyMessageTypes . message2 , number = 42 ) >>> print ( message1 ) foobar : johndoe >>> print ( message2 ) foobar : 1764 Source code in pycmdlineapp_groundwork/factory/factory.py def register_builder ( self , builder_type : Union [ Type [ TGenericBuilder ], GenericBuilder ], type_descriptor_key : Union [ StrDescriptor , IntDescriptor , None ] = None , artifact_type : Union [ Type [ TGenericBuildArtifact ], None ] = None ) -> None : \"\"\"Register a builder, either by giving the builders class, the descriptor and the class type it shall create or by giving an already instantiated builder object. After registering, calling the factory with a descriptor uses the registeredbuilder to build the associated objects. Args: type_descriptor_key: The enum-derived descriptor identifying the class-object to be built. builder_type: The builder used to create instances of the artifact type. Must be derived from GenericBuilder. artifact_type: The class type to be built. Must be derived from GenericBuildArtifact. Example: ```python >>> class MyMessage(GenericBuildArtifact): ... _context= \"\" ... _text= \"\" ... def __str__(self): ... return f'{self._context}: {self._text}' >>> class MyMessage1(MyMessage): ... def __init__(self, context, text): ... self._text= text ... self._context= context >>> class MyMessage2(MyMessage): ... def __init__(self, context, number): ... self._text= str(number * 42) ... self._context= context >>> class MyMessageTypes(IntDescriptor): ... message1= auto() ... message2= auto() >>> class MyMessageBuilder(GenericBuilder): ... def init_hook(self): ... self.set_fixed_args(context= \"foobar\") >>> message_provider= Factory() >>> message1_builder= MyMessageBuilder(MyMessageTypes.message1, MyMessage1) >>> message2_builder= MyMessageBuilder(MyMessageTypes.message2, MyMessage2) >>> message_provider.register_builder(message1_builder) >>> message_provider.register_builder(message2_builder) >>> message1= message_provider(MyMessageTypes.message1, text= \"johndoe\") >>> message2= message_provider(MyMessageTypes.message2, number= 42) >>> print(message1) foobar: johndoe >>> print(message2) foobar: 1764 ``` \"\"\" if builder_type is None : raise ValueError ( f ' { self . __class__ . __name__ } : builder_type cannot be None.' ) if not isinstance ( builder_type , GenericBuilder ) and type_descriptor_key is None : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key cannot be None, if builder_type is not an instance of GenericBuilder.' ) if not isinstance ( builder_type , GenericBuilder ) and artifact_type is None : raise ValueError ( f ' { self . __class__ . __name__ } : artifact_type cannot be None, if builder_type is not an instance of GenericBuilder.' ) if type_descriptor_key is not None and type_descriptor_key in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key { type_descriptor_key } already registered to build { self . _builder_registry [ type_descriptor_key ] } .' ) if isinstance ( builder_type , GenericBuilder ): for type_descriptor_key in builder_type . _registry . keys (): if type_descriptor_key in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : trying to register builder \\' { builder_type } \\' , but type_descriptor_key { type_descriptor_key } already registered in factory to build { self . _builder_registry [ type_descriptor_key ] } .' ) else : self . _builder_registry [ type_descriptor_key ] = builder_type else : self . _builder_registry [ type_descriptor_key ] = builder_type ( type_descriptor_key , artifact_type )","title":"Factory"},{"location":"reference/factory/#factory-utilities","text":"Collection of object builders to create object based on an enum/Descriptor type. Can be directly used with GenericBuilders or specialized builders or can be derived from to eg. pre-register builders. Inspired by RealPython Examples: >>> class MyMessage ( GenericBuildArtifact ): ... _context = \"\" ... _text = \"\" ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessage1 ( MyMessage ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context >>> class MyMessage2 ( MyMessage ): ... def __init__ ( self , context , number ): ... self . _text = str ( number * 42 ) ... self . _context = context >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () ... message2 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> class MyMessageFactory ( Factory ): ... def __init__ ( self ): ... super () . __init__ () ... self . register_builder ( MyMessageBuilder , MyMessageTypes . message1 , MyMessage1 ) ... self . register_builder ( MyMessageBuilder , MyMessageTypes . message2 , MyMessage2 ) >>> message_provider = MyMessageFactory () >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> message2 = message_provider ( MyMessageTypes . message2 , number = 42 ) >>> print ( message1 ) foobar : johndoe >>> print ( message2 ) foobar : 1764","title":"Factory Utilities"},{"location":"reference/factory/#pycmdlineapp_groundwork.factory.factory.Factory.__call__","text":"Build and return an object referred to by type_descriptor_key using the builder registered for this object type. Parameters: Name Type Description Default type_descriptor_key Union[pycmdlineapp_groundwork.factory.descriptor.StrDescriptor, pycmdlineapp_groundwork.factory.descriptor.IntDescriptor] The enum-derived descriptor identifying the class-object to be built. None *args Positional arguments passed to the registered object builder. () **kwargs Keyword arguments passed to the registered object builder. {} Returns: Type Description ~TGenericBuildArtifact instance of class type (descendant of GenericBuildArtefact) associated with type_descriptor_key Examples: >>> class MyMessage ( GenericBuildArtifact ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> message_provider = Factory () >>> message_provider . register_builder ( MyMessageBuilder , MyMessageTypes . message1 , MyMessage ) >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> print ( message1 ) foobar : johndoe Source code in pycmdlineapp_groundwork/factory/factory.py def __call__ ( self , type_descriptor_key : Union [ StrDescriptor , IntDescriptor ] = None , * args , ** kwargs ) -> TGenericBuildArtifact : \"\"\"Build and return an object referred to by type_descriptor_key using the builder registered for this object type. Args: type_descriptor_key: The enum-derived descriptor identifying the class-object to be built. *args: Positional arguments passed to the registered object builder. **kwargs: Keyword arguments passed to the registered object builder. Returns: instance of class type (descendant of GenericBuildArtefact) associated with type_descriptor_key Example: ```python >>> class MyMessage(GenericBuildArtifact): ... def __init__(self, context, text): ... self._text= text ... self._context= context ... def __str__(self): ... return f'{self._context}: {self._text}' >>> class MyMessageTypes(IntDescriptor): ... message1= auto() >>> class MyMessageBuilder(GenericBuilder): ... def init_hook(self): ... self.set_fixed_args(context= \"foobar\") >>> message_provider= Factory() >>> message_provider.register_builder(MyMessageBuilder, MyMessageTypes.message1, MyMessage) >>> message1= message_provider(MyMessageTypes.message1, text= \"johndoe\") >>> print(message1) foobar: johndoe ``` \"\"\" if type_descriptor_key is None : if self . _builder_registry == {}: raise ValueError ( f ' { self . __class__ . __name__ } : No build artifacts registered, don \\' t know which builder to use.' ) type_descriptor_key = next ( iter ( self . _builder_registry )) if type_descriptor_key not in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key { type_descriptor_key } not yet registered, don \\' t know which builder to use.' ) return self . _builder_registry [ type_descriptor_key ]( type_descriptor_key , * args , ** kwargs )","title":"__call__()"},{"location":"reference/factory/#pycmdlineapp_groundwork.factory.factory.Factory.register_builder","text":"Register a builder, either by giving the builders class, the descriptor and the class type it shall create or by giving an already instantiated builder object. After registering, calling the factory with a descriptor uses the registeredbuilder to build the associated objects. Parameters: Name Type Description Default type_descriptor_key Union[pycmdlineapp_groundwork.factory.descriptor.StrDescriptor, pycmdlineapp_groundwork.factory.descriptor.IntDescriptor] The enum-derived descriptor identifying the class-object to be built. None builder_type Union[Type[~TGenericBuilder], pycmdlineapp_groundwork.factory.builder.GenericBuilder] The builder used to create instances of the artifact type. Must be derived from GenericBuilder. required artifact_type Optional[Type[~TGenericBuildArtifact]] The class type to be built. Must be derived from GenericBuildArtifact. None Examples: >>> class MyMessage ( GenericBuildArtifact ): ... _context = \"\" ... _text = \"\" ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessage1 ( MyMessage ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context >>> class MyMessage2 ( MyMessage ): ... def __init__ ( self , context , number ): ... self . _text = str ( number * 42 ) ... self . _context = context >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () ... message2 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> message_provider = Factory () >>> message1_builder = MyMessageBuilder ( MyMessageTypes . message1 , MyMessage1 ) >>> message2_builder = MyMessageBuilder ( MyMessageTypes . message2 , MyMessage2 ) >>> message_provider . register_builder ( message1_builder ) >>> message_provider . register_builder ( message2_builder ) >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> message2 = message_provider ( MyMessageTypes . message2 , number = 42 ) >>> print ( message1 ) foobar : johndoe >>> print ( message2 ) foobar : 1764 Source code in pycmdlineapp_groundwork/factory/factory.py def register_builder ( self , builder_type : Union [ Type [ TGenericBuilder ], GenericBuilder ], type_descriptor_key : Union [ StrDescriptor , IntDescriptor , None ] = None , artifact_type : Union [ Type [ TGenericBuildArtifact ], None ] = None ) -> None : \"\"\"Register a builder, either by giving the builders class, the descriptor and the class type it shall create or by giving an already instantiated builder object. After registering, calling the factory with a descriptor uses the registeredbuilder to build the associated objects. Args: type_descriptor_key: The enum-derived descriptor identifying the class-object to be built. builder_type: The builder used to create instances of the artifact type. Must be derived from GenericBuilder. artifact_type: The class type to be built. Must be derived from GenericBuildArtifact. Example: ```python >>> class MyMessage(GenericBuildArtifact): ... _context= \"\" ... _text= \"\" ... def __str__(self): ... return f'{self._context}: {self._text}' >>> class MyMessage1(MyMessage): ... def __init__(self, context, text): ... self._text= text ... self._context= context >>> class MyMessage2(MyMessage): ... def __init__(self, context, number): ... self._text= str(number * 42) ... self._context= context >>> class MyMessageTypes(IntDescriptor): ... message1= auto() ... message2= auto() >>> class MyMessageBuilder(GenericBuilder): ... def init_hook(self): ... self.set_fixed_args(context= \"foobar\") >>> message_provider= Factory() >>> message1_builder= MyMessageBuilder(MyMessageTypes.message1, MyMessage1) >>> message2_builder= MyMessageBuilder(MyMessageTypes.message2, MyMessage2) >>> message_provider.register_builder(message1_builder) >>> message_provider.register_builder(message2_builder) >>> message1= message_provider(MyMessageTypes.message1, text= \"johndoe\") >>> message2= message_provider(MyMessageTypes.message2, number= 42) >>> print(message1) foobar: johndoe >>> print(message2) foobar: 1764 ``` \"\"\" if builder_type is None : raise ValueError ( f ' { self . __class__ . __name__ } : builder_type cannot be None.' ) if not isinstance ( builder_type , GenericBuilder ) and type_descriptor_key is None : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key cannot be None, if builder_type is not an instance of GenericBuilder.' ) if not isinstance ( builder_type , GenericBuilder ) and artifact_type is None : raise ValueError ( f ' { self . __class__ . __name__ } : artifact_type cannot be None, if builder_type is not an instance of GenericBuilder.' ) if type_descriptor_key is not None and type_descriptor_key in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key { type_descriptor_key } already registered to build { self . _builder_registry [ type_descriptor_key ] } .' ) if isinstance ( builder_type , GenericBuilder ): for type_descriptor_key in builder_type . _registry . keys (): if type_descriptor_key in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : trying to register builder \\' { builder_type } \\' , but type_descriptor_key { type_descriptor_key } already registered in factory to build { self . _builder_registry [ type_descriptor_key ] } .' ) else : self . _builder_registry [ type_descriptor_key ] = builder_type else : self . _builder_registry [ type_descriptor_key ] = builder_type ( type_descriptor_key , artifact_type )","title":"register_builder()"},{"location":"usage/settings/","text":"Application settings management \ud83d\udd17","title":"Settings Management"},{"location":"usage/settings/#application-settings-management","text":"","title":"Application settings management"}]}