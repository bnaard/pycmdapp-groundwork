{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pycmdlineapp_groundworks \ud83d\udd17 pycmdlineapp_groundworks is an opinionated collection of libraries, code and best-practice descriptions to jumpstart the development for mid-level to complex python command-line applications (think: git command line client). Features \ud83d\udd17 The toolset solves the following challenges: Challenge I would like to have ... Solution Commandline parsing Mulit-/Subcommand with arguments and options (all forms, like single, multiple, typed, with prompt, ...), validated and with automatic help click provides all, is stables has an excellent help and a large community Settings management Schema-validated, documented and probably pre-processed settings from different sources (config files, environment variables, .env files, secret files), coordinated with click default values and input from command-line arguments Using pydantic in connection with climatecontrol for missing features (multi-config-file load & merge, config-file format support for toml/yaml/json, environment variables for nested configs like for click-subcommands) and docstring extraction from pydantic-settings Logging setup Flexible, configurable, thread-safe logging setup writing to multiple destinations (console, files, network targets, ...) and with verbosity configurable from commandline Python standard logging facilities in combination with commandline parsing and settings management Multi-progress bar Thread-safe colored progressbar with options for multiple bars, counters and clutter-free printing of log-/error-messages Using enlighten progress-bar library Factory methods Ability to create objects with a factory-class based on enum types (example use case: message objects created by a message-provider-class) Factory implementation inspired by https://realpython.com/factory-method-python/ Install \ud83d\udd17 tbd Quick Start \ud83d\udd17 tbd For further details please see documentation ) Documentation \ud83d\udd17 Documentation Contributing \ud83d\udd17 tbd","title":"Overview"},{"location":"#welcome-to-pycmdlineapp_groundworks","text":"pycmdlineapp_groundworks is an opinionated collection of libraries, code and best-practice descriptions to jumpstart the development for mid-level to complex python command-line applications (think: git command line client).","title":"Welcome to pycmdlineapp_groundworks"},{"location":"#features","text":"The toolset solves the following challenges: Challenge I would like to have ... Solution Commandline parsing Mulit-/Subcommand with arguments and options (all forms, like single, multiple, typed, with prompt, ...), validated and with automatic help click provides all, is stables has an excellent help and a large community Settings management Schema-validated, documented and probably pre-processed settings from different sources (config files, environment variables, .env files, secret files), coordinated with click default values and input from command-line arguments Using pydantic in connection with climatecontrol for missing features (multi-config-file load & merge, config-file format support for toml/yaml/json, environment variables for nested configs like for click-subcommands) and docstring extraction from pydantic-settings Logging setup Flexible, configurable, thread-safe logging setup writing to multiple destinations (console, files, network targets, ...) and with verbosity configurable from commandline Python standard logging facilities in combination with commandline parsing and settings management Multi-progress bar Thread-safe colored progressbar with options for multiple bars, counters and clutter-free printing of log-/error-messages Using enlighten progress-bar library Factory methods Ability to create objects with a factory-class based on enum types (example use case: message objects created by a message-provider-class) Factory implementation inspired by https://realpython.com/factory-method-python/","title":"Features"},{"location":"#install","text":"tbd","title":"Install"},{"location":"#quick-start","text":"tbd For further details please see documentation )","title":"Quick Start"},{"location":"#documentation","text":"Documentation","title":"Documentation"},{"location":"#contributing","text":"tbd","title":"Contributing"},{"location":"changelog/","text":"Changelog \ud83d\udd17 All notable changes to this project are documented in this file. [Unreleased] \ud83d\udd17 Added \ud83d\udd17 Changed \ud83d\udd17 Removed \ud83d\udd17 Fixed \ud83d\udd17 [0.1.0] - 2021-03-21 \ud83d\udd17 Added \ud83d\udd17 default configuration and configuration parsing initial documentation build factory implementation Changed \ud83d\udd17 Removed \ud83d\udd17 Fixed \ud83d\udd17","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project are documented in this file.","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#added","text":"","title":"Added"},{"location":"changelog/#changed","text":"","title":"Changed"},{"location":"changelog/#removed","text":"","title":"Removed"},{"location":"changelog/#fixed","text":"","title":"Fixed"},{"location":"changelog/#010-2021-03-21","text":"","title":"[0.1.0] - 2021-03-21"},{"location":"changelog/#added_1","text":"default configuration and configuration parsing initial documentation build factory implementation","title":"Added"},{"location":"changelog/#changed_1","text":"","title":"Changed"},{"location":"changelog/#removed_1","text":"","title":"Removed"},{"location":"changelog/#fixed_1","text":"","title":"Fixed"},{"location":"contributing/","text":"Contributing \ud83d\udd17 We'd be happy to get your contribution to this project! Issues \ud83d\udd17 Questions, feature requests and bug reports are all welcome as discussions or issues . Security Policy \ud83d\udd17 Please refer to our Security Policy . Pull Requests \ud83d\udd17 It's simple to get started and create a Pull Request. pycmdlineapp_groundwork has few dependencies, doesn't require compiling and tests don't need access to databases, etc. pycmdlineapp_groundwork is released regularly so you should see your improvements release in a matter of weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for immediate possibilities to contribute, look out for the label \"help wanted\" in issues . Prerequsites \ud83d\udd17 Mandatory: python 3.8 or later installed Mandatory: python-poetry installed Mandatory: git installed Optionally: You can work with VS Code and development containers . See Optional VS Code Setup description . Development setup \ud83d\udd17 Please follow these steps to contribute: Clone your fork and cd into the repo directory git clone git clone https://github.com/bnaard/pycmdlineapp-groundwork.git cd pycmdlineapp-groundwork Set up a virtualenv and install dependencies: poetry install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: planned : using black to enforce formatting and isort to fix imports (https://github.com/ambv/black, https://github.com/timothycrosley/isort) Run linting planned using flake8 as linter Run tests and coverage pytest --cov = pycmdlineapp-groundwork Build and preview documentation mike deploy mike serve ... commit, push, and create your pull request Optional VS Code setup \ud83d\udd17 tbd","title":"Contributing"},{"location":"contributing/#contributing","text":"We'd be happy to get your contribution to this project!","title":"Contributing"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as discussions or issues .","title":"Issues"},{"location":"contributing/#security-policy","text":"Please refer to our Security Policy .","title":"Security Policy"},{"location":"contributing/#pull-requests","text":"It's simple to get started and create a Pull Request. pycmdlineapp_groundwork has few dependencies, doesn't require compiling and tests don't need access to databases, etc. pycmdlineapp_groundwork is released regularly so you should see your improvements release in a matter of weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for immediate possibilities to contribute, look out for the label \"help wanted\" in issues .","title":"Pull Requests"},{"location":"contributing/#prerequsites","text":"Mandatory: python 3.8 or later installed Mandatory: python-poetry installed Mandatory: git installed Optionally: You can work with VS Code and development containers . See Optional VS Code Setup description .","title":"Prerequsites"},{"location":"contributing/#development-setup","text":"Please follow these steps to contribute: Clone your fork and cd into the repo directory git clone git clone https://github.com/bnaard/pycmdlineapp-groundwork.git cd pycmdlineapp-groundwork Set up a virtualenv and install dependencies: poetry install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: planned : using black to enforce formatting and isort to fix imports (https://github.com/ambv/black, https://github.com/timothycrosley/isort) Run linting planned using flake8 as linter Run tests and coverage pytest --cov = pycmdlineapp-groundwork Build and preview documentation mike deploy mike serve ... commit, push, and create your pull request","title":"Development setup"},{"location":"contributing/#optional-vs-code-setup","text":"tbd","title":"Optional VS Code setup"},{"location":"development/","text":"Development \ud83d\udd17 Build Tool \ud83d\udd17 The project's dependencies, build-chain and deployment to PyPI is managed with Python Poetry . Main project information is manged in file pyproject.toml Dependencies to the production are added by poetry add <pypi-package-name> or removed by poetry remove <pypi-package-name> Dependencies only needed for development are added by poetry add --dev <pypi-package-name> or removed by poetry remove --dev <pypi-package-name> In case of problems, it usually helps to delete the automatically generated poetry.lock -file and to run poetry install to reinstall all dependencies with recalculation of dependency tree. Versioning \ud83d\udd17 Versioning is managed also by Python Poetry using SemVer : Major version update: poetry version major (for large releases with completely new feature sets and/or breakting API) Minor version update: poetry version minor (for minor feature additions and/or non-breaking api changes) Patch version update: poetry version patch (for bugfixes, minor documentation updates) Though versioning is managed with Python Poetry , the version definition needs manual update in the following steps and locations: Major/Minor/Patch version update using one of the above poetry version commands Manual update of pycmdlineapp_groundwork/__init__.py:__version__ Manual update of command for rebuilding the documentation (only for preview locally, production versioning is handled in Github actions). See section Documentation below. Documentation \ud83d\udd17 Documentation is build using mkdocs static page generator with several plugins which allow versioning, integration of docstring comments and deploying to Github pages . The advantages of this approach are greater flexibility in page setup and design, integration of docstring comments and examples and simple local preview. The main plugins are: For great design, search and navigation: mkdocs-material For integration of docstring comments: mkdoc-strings For versioning: mike The Github action described in .github/workflows/docs.yml is based on GitHub Actions for GitHub Pages , which builds and deploys mkdoc page structures and takes care that Github is serving those as is instead of using Jekyll. All productive documentation is hosted on gh-pages -branch of this repository. This is automatically managed and overwritten by the mkdoc -tools mentioned above. So, do not edit manually the gh-pages -branch as all your changes will be overwritten and lost on next documentation auto-build+deploy. In the Github actions, the latest version is retrieved using get-latest-tag to build the latest documentation. While documentation updates including documentation versions on Github are automatically done based on latest tag information (see .github/workflows/Docs.yml ), you need to run the following to locally build and serve the versioned documentation for preview on https://localhost:8000 : mike deploy --update-aliases 0 .1.0 latest # replace 0.1.0 manually with the current version from pycmdlineapp_groundwork/__init__.py mike set-default latest mike serve Note that you have to run both commands to get a proper redirect to the latest documentation on https://localhost:8000 . Refer to mkdocs-material documentation and to mike documentation for details.","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#build-tool","text":"The project's dependencies, build-chain and deployment to PyPI is managed with Python Poetry . Main project information is manged in file pyproject.toml Dependencies to the production are added by poetry add <pypi-package-name> or removed by poetry remove <pypi-package-name> Dependencies only needed for development are added by poetry add --dev <pypi-package-name> or removed by poetry remove --dev <pypi-package-name> In case of problems, it usually helps to delete the automatically generated poetry.lock -file and to run poetry install to reinstall all dependencies with recalculation of dependency tree.","title":"Build Tool"},{"location":"development/#versioning","text":"Versioning is managed also by Python Poetry using SemVer : Major version update: poetry version major (for large releases with completely new feature sets and/or breakting API) Minor version update: poetry version minor (for minor feature additions and/or non-breaking api changes) Patch version update: poetry version patch (for bugfixes, minor documentation updates) Though versioning is managed with Python Poetry , the version definition needs manual update in the following steps and locations: Major/Minor/Patch version update using one of the above poetry version commands Manual update of pycmdlineapp_groundwork/__init__.py:__version__ Manual update of command for rebuilding the documentation (only for preview locally, production versioning is handled in Github actions). See section Documentation below.","title":"Versioning"},{"location":"development/#documentation","text":"Documentation is build using mkdocs static page generator with several plugins which allow versioning, integration of docstring comments and deploying to Github pages . The advantages of this approach are greater flexibility in page setup and design, integration of docstring comments and examples and simple local preview. The main plugins are: For great design, search and navigation: mkdocs-material For integration of docstring comments: mkdoc-strings For versioning: mike The Github action described in .github/workflows/docs.yml is based on GitHub Actions for GitHub Pages , which builds and deploys mkdoc page structures and takes care that Github is serving those as is instead of using Jekyll. All productive documentation is hosted on gh-pages -branch of this repository. This is automatically managed and overwritten by the mkdoc -tools mentioned above. So, do not edit manually the gh-pages -branch as all your changes will be overwritten and lost on next documentation auto-build+deploy. In the Github actions, the latest version is retrieved using get-latest-tag to build the latest documentation. While documentation updates including documentation versions on Github are automatically done based on latest tag information (see .github/workflows/Docs.yml ), you need to run the following to locally build and serve the versioned documentation for preview on https://localhost:8000 : mike deploy --update-aliases 0 .1.0 latest # replace 0.1.0 manually with the current version from pycmdlineapp_groundwork/__init__.py mike set-default latest mike serve Note that you have to run both commands to get a proper redirect to the latest documentation on https://localhost:8000 . Refer to mkdocs-material documentation and to mike documentation for details.","title":"Documentation"},{"location":"install/","text":"","title":"Install"},{"location":"license/","text":"MIT License Copyright (c) 2021 bnaard Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"reference/factory/","text":"Factory Utilities \ud83d\udd17 Collection of object builders to create object based on an enum/Descriptor type. Can be directly used with GenericBuilders or specialized builders or can be derived from to eg. pre-register builders. Inspired by RealPython Examples: >>> class MyMessage ( GenericBuildArtifact ): ... _context = \"\" ... _text = \"\" ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessage1 ( MyMessage ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context >>> class MyMessage2 ( MyMessage ): ... def __init__ ( self , context , number ): ... self . _text = str ( number * 42 ) ... self . _context = context >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () ... message2 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> class MyMessageFactory ( Factory ): ... def __init__ ( self ): ... super () . __init__ () ... self . register_builder ( MyMessageBuilder , MyMessageTypes . message1 , MyMessage1 ) ... self . register_builder ( MyMessageBuilder , MyMessageTypes . message2 , MyMessage2 ) >>> message_provider = MyMessageFactory () >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> message2 = message_provider ( MyMessageTypes . message2 , number = 42 ) >>> print ( message1 ) foobar : johndoe >>> print ( message2 ) foobar : 1764 __call__ ( self , type_descriptor_key = None , * args , ** kwargs ) special \ud83d\udd17 Build and return an object referred to by type_descriptor_key using the builder registered for this object type. Parameters: Name Type Description Default type_descriptor_key Union[pycmdlineapp_groundwork.factory.descriptor.StrDescriptor, pycmdlineapp_groundwork.factory.descriptor.IntDescriptor] The enum-derived descriptor identifying the class-object to be built. None *args Positional arguments passed to the registered object builder. () **kwargs Keyword arguments passed to the registered object builder. {} Returns: Type Description ~TGenericBuildArtifact instance of class type (descendant of GenericBuildArtefact) associated with type_descriptor_key Examples: >>> class MyMessage ( GenericBuildArtifact ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> message_provider = Factory () >>> message_provider . register_builder ( MyMessageBuilder , MyMessageTypes . message1 , MyMessage ) >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> print ( message1 ) foobar : johndoe Source code in pycmdlineapp_groundwork/factory/factory.py def __call__ ( self , type_descriptor_key : Union [ StrDescriptor , IntDescriptor ] = None , * args , ** kwargs ) -> TGenericBuildArtifact : \"\"\"Build and return an object referred to by type_descriptor_key using the builder registered for this object type. Args: type_descriptor_key: The enum-derived descriptor identifying the class-object to be built. *args: Positional arguments passed to the registered object builder. **kwargs: Keyword arguments passed to the registered object builder. Returns: instance of class type (descendant of GenericBuildArtefact) associated with type_descriptor_key Example: ```python >>> class MyMessage(GenericBuildArtifact): ... def __init__(self, context, text): ... self._text= text ... self._context= context ... def __str__(self): ... return f'{self._context}: {self._text}' >>> class MyMessageTypes(IntDescriptor): ... message1= auto() >>> class MyMessageBuilder(GenericBuilder): ... def init_hook(self): ... self.set_fixed_args(context= \"foobar\") >>> message_provider= Factory() >>> message_provider.register_builder(MyMessageBuilder, MyMessageTypes.message1, MyMessage) >>> message1= message_provider(MyMessageTypes.message1, text= \"johndoe\") >>> print(message1) foobar: johndoe ``` \"\"\" if type_descriptor_key is None : if self . _builder_registry == {}: raise ValueError ( f ' { self . __class__ . __name__ } : No build artifacts registered, don \\' t know which builder to use.' ) type_descriptor_key = next ( iter ( self . _builder_registry )) if type_descriptor_key not in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key { type_descriptor_key } not yet registered, don \\' t know which builder to use.' ) return self . _builder_registry [ type_descriptor_key ]( type_descriptor_key , * args , ** kwargs ) register_builder ( self , builder_type , type_descriptor_key = None , artifact_type = None ) \ud83d\udd17 Register a builder, either by giving the builders class, the descriptor and the class type it shall create or by giving an already instantiated builder object. After registering, calling the factory with a descriptor uses the registeredbuilder to build the associated objects. Parameters: Name Type Description Default type_descriptor_key Union[pycmdlineapp_groundwork.factory.descriptor.StrDescriptor, pycmdlineapp_groundwork.factory.descriptor.IntDescriptor] The enum-derived descriptor identifying the class-object to be built. None builder_type Union[Type[~TGenericBuilder], pycmdlineapp_groundwork.factory.builder.GenericBuilder] The builder used to create instances of the artifact type. Must be derived from GenericBuilder. required artifact_type Optional[Type[~TGenericBuildArtifact]] The class type to be built. Must be derived from GenericBuildArtifact. None Examples: >>> class MyMessage ( GenericBuildArtifact ): ... _context = \"\" ... _text = \"\" ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessage1 ( MyMessage ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context >>> class MyMessage2 ( MyMessage ): ... def __init__ ( self , context , number ): ... self . _text = str ( number * 42 ) ... self . _context = context >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () ... message2 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> message_provider = Factory () >>> message1_builder = MyMessageBuilder ( MyMessageTypes . message1 , MyMessage1 ) >>> message2_builder = MyMessageBuilder ( MyMessageTypes . message2 , MyMessage2 ) >>> message_provider . register_builder ( message1_builder ) >>> message_provider . register_builder ( message2_builder ) >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> message2 = message_provider ( MyMessageTypes . message2 , number = 42 ) >>> print ( message1 ) foobar : johndoe >>> print ( message2 ) foobar : 1764 Source code in pycmdlineapp_groundwork/factory/factory.py def register_builder ( self , builder_type : Union [ Type [ TGenericBuilder ], GenericBuilder ], type_descriptor_key : Union [ StrDescriptor , IntDescriptor , None ] = None , artifact_type : Union [ Type [ TGenericBuildArtifact ], None ] = None ) -> None : \"\"\"Register a builder, either by giving the builders class, the descriptor and the class type it shall create or by giving an already instantiated builder object. After registering, calling the factory with a descriptor uses the registeredbuilder to build the associated objects. Args: type_descriptor_key: The enum-derived descriptor identifying the class-object to be built. builder_type: The builder used to create instances of the artifact type. Must be derived from GenericBuilder. artifact_type: The class type to be built. Must be derived from GenericBuildArtifact. Example: ```python >>> class MyMessage(GenericBuildArtifact): ... _context= \"\" ... _text= \"\" ... def __str__(self): ... return f'{self._context}: {self._text}' >>> class MyMessage1(MyMessage): ... def __init__(self, context, text): ... self._text= text ... self._context= context >>> class MyMessage2(MyMessage): ... def __init__(self, context, number): ... self._text= str(number * 42) ... self._context= context >>> class MyMessageTypes(IntDescriptor): ... message1= auto() ... message2= auto() >>> class MyMessageBuilder(GenericBuilder): ... def init_hook(self): ... self.set_fixed_args(context= \"foobar\") >>> message_provider= Factory() >>> message1_builder= MyMessageBuilder(MyMessageTypes.message1, MyMessage1) >>> message2_builder= MyMessageBuilder(MyMessageTypes.message2, MyMessage2) >>> message_provider.register_builder(message1_builder) >>> message_provider.register_builder(message2_builder) >>> message1= message_provider(MyMessageTypes.message1, text= \"johndoe\") >>> message2= message_provider(MyMessageTypes.message2, number= 42) >>> print(message1) foobar: johndoe >>> print(message2) foobar: 1764 ``` \"\"\" if builder_type is None : raise ValueError ( f ' { self . __class__ . __name__ } : builder_type cannot be None.' ) if not isinstance ( builder_type , GenericBuilder ) and type_descriptor_key is None : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key cannot be None, if builder_type is not an instance of GenericBuilder.' ) if not isinstance ( builder_type , GenericBuilder ) and artifact_type is None : raise ValueError ( f ' { self . __class__ . __name__ } : artifact_type cannot be None, if builder_type is not an instance of GenericBuilder.' ) if type_descriptor_key is not None and type_descriptor_key in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key { type_descriptor_key } already registered to build { self . _builder_registry [ type_descriptor_key ] } .' ) if isinstance ( builder_type , GenericBuilder ): for type_descriptor_key in builder_type . _registry . keys (): if type_descriptor_key in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : trying to register builder \\' { builder_type } \\' , but type_descriptor_key { type_descriptor_key } already registered in factory to build { self . _builder_registry [ type_descriptor_key ] } .' ) else : self . _builder_registry [ type_descriptor_key ] = builder_type else : self . _builder_registry [ type_descriptor_key ] = builder_type ( type_descriptor_key , artifact_type )","title":"Factory"},{"location":"reference/factory/#factory-utilities","text":"Collection of object builders to create object based on an enum/Descriptor type. Can be directly used with GenericBuilders or specialized builders or can be derived from to eg. pre-register builders. Inspired by RealPython Examples: >>> class MyMessage ( GenericBuildArtifact ): ... _context = \"\" ... _text = \"\" ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessage1 ( MyMessage ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context >>> class MyMessage2 ( MyMessage ): ... def __init__ ( self , context , number ): ... self . _text = str ( number * 42 ) ... self . _context = context >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () ... message2 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> class MyMessageFactory ( Factory ): ... def __init__ ( self ): ... super () . __init__ () ... self . register_builder ( MyMessageBuilder , MyMessageTypes . message1 , MyMessage1 ) ... self . register_builder ( MyMessageBuilder , MyMessageTypes . message2 , MyMessage2 ) >>> message_provider = MyMessageFactory () >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> message2 = message_provider ( MyMessageTypes . message2 , number = 42 ) >>> print ( message1 ) foobar : johndoe >>> print ( message2 ) foobar : 1764","title":"Factory Utilities"},{"location":"reference/factory/#pycmdlineapp_groundwork.factory.factory.Factory.__call__","text":"Build and return an object referred to by type_descriptor_key using the builder registered for this object type. Parameters: Name Type Description Default type_descriptor_key Union[pycmdlineapp_groundwork.factory.descriptor.StrDescriptor, pycmdlineapp_groundwork.factory.descriptor.IntDescriptor] The enum-derived descriptor identifying the class-object to be built. None *args Positional arguments passed to the registered object builder. () **kwargs Keyword arguments passed to the registered object builder. {} Returns: Type Description ~TGenericBuildArtifact instance of class type (descendant of GenericBuildArtefact) associated with type_descriptor_key Examples: >>> class MyMessage ( GenericBuildArtifact ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> message_provider = Factory () >>> message_provider . register_builder ( MyMessageBuilder , MyMessageTypes . message1 , MyMessage ) >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> print ( message1 ) foobar : johndoe Source code in pycmdlineapp_groundwork/factory/factory.py def __call__ ( self , type_descriptor_key : Union [ StrDescriptor , IntDescriptor ] = None , * args , ** kwargs ) -> TGenericBuildArtifact : \"\"\"Build and return an object referred to by type_descriptor_key using the builder registered for this object type. Args: type_descriptor_key: The enum-derived descriptor identifying the class-object to be built. *args: Positional arguments passed to the registered object builder. **kwargs: Keyword arguments passed to the registered object builder. Returns: instance of class type (descendant of GenericBuildArtefact) associated with type_descriptor_key Example: ```python >>> class MyMessage(GenericBuildArtifact): ... def __init__(self, context, text): ... self._text= text ... self._context= context ... def __str__(self): ... return f'{self._context}: {self._text}' >>> class MyMessageTypes(IntDescriptor): ... message1= auto() >>> class MyMessageBuilder(GenericBuilder): ... def init_hook(self): ... self.set_fixed_args(context= \"foobar\") >>> message_provider= Factory() >>> message_provider.register_builder(MyMessageBuilder, MyMessageTypes.message1, MyMessage) >>> message1= message_provider(MyMessageTypes.message1, text= \"johndoe\") >>> print(message1) foobar: johndoe ``` \"\"\" if type_descriptor_key is None : if self . _builder_registry == {}: raise ValueError ( f ' { self . __class__ . __name__ } : No build artifacts registered, don \\' t know which builder to use.' ) type_descriptor_key = next ( iter ( self . _builder_registry )) if type_descriptor_key not in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key { type_descriptor_key } not yet registered, don \\' t know which builder to use.' ) return self . _builder_registry [ type_descriptor_key ]( type_descriptor_key , * args , ** kwargs )","title":"__call__()"},{"location":"reference/factory/#pycmdlineapp_groundwork.factory.factory.Factory.register_builder","text":"Register a builder, either by giving the builders class, the descriptor and the class type it shall create or by giving an already instantiated builder object. After registering, calling the factory with a descriptor uses the registeredbuilder to build the associated objects. Parameters: Name Type Description Default type_descriptor_key Union[pycmdlineapp_groundwork.factory.descriptor.StrDescriptor, pycmdlineapp_groundwork.factory.descriptor.IntDescriptor] The enum-derived descriptor identifying the class-object to be built. None builder_type Union[Type[~TGenericBuilder], pycmdlineapp_groundwork.factory.builder.GenericBuilder] The builder used to create instances of the artifact type. Must be derived from GenericBuilder. required artifact_type Optional[Type[~TGenericBuildArtifact]] The class type to be built. Must be derived from GenericBuildArtifact. None Examples: >>> class MyMessage ( GenericBuildArtifact ): ... _context = \"\" ... _text = \"\" ... def __str__ ( self ): ... return f ' { self . _context } : { self . _text } ' >>> class MyMessage1 ( MyMessage ): ... def __init__ ( self , context , text ): ... self . _text = text ... self . _context = context >>> class MyMessage2 ( MyMessage ): ... def __init__ ( self , context , number ): ... self . _text = str ( number * 42 ) ... self . _context = context >>> class MyMessageTypes ( IntDescriptor ): ... message1 = auto () ... message2 = auto () >>> class MyMessageBuilder ( GenericBuilder ): ... def init_hook ( self ): ... self . set_fixed_args ( context = \"foobar\" ) >>> message_provider = Factory () >>> message1_builder = MyMessageBuilder ( MyMessageTypes . message1 , MyMessage1 ) >>> message2_builder = MyMessageBuilder ( MyMessageTypes . message2 , MyMessage2 ) >>> message_provider . register_builder ( message1_builder ) >>> message_provider . register_builder ( message2_builder ) >>> message1 = message_provider ( MyMessageTypes . message1 , text = \"johndoe\" ) >>> message2 = message_provider ( MyMessageTypes . message2 , number = 42 ) >>> print ( message1 ) foobar : johndoe >>> print ( message2 ) foobar : 1764 Source code in pycmdlineapp_groundwork/factory/factory.py def register_builder ( self , builder_type : Union [ Type [ TGenericBuilder ], GenericBuilder ], type_descriptor_key : Union [ StrDescriptor , IntDescriptor , None ] = None , artifact_type : Union [ Type [ TGenericBuildArtifact ], None ] = None ) -> None : \"\"\"Register a builder, either by giving the builders class, the descriptor and the class type it shall create or by giving an already instantiated builder object. After registering, calling the factory with a descriptor uses the registeredbuilder to build the associated objects. Args: type_descriptor_key: The enum-derived descriptor identifying the class-object to be built. builder_type: The builder used to create instances of the artifact type. Must be derived from GenericBuilder. artifact_type: The class type to be built. Must be derived from GenericBuildArtifact. Example: ```python >>> class MyMessage(GenericBuildArtifact): ... _context= \"\" ... _text= \"\" ... def __str__(self): ... return f'{self._context}: {self._text}' >>> class MyMessage1(MyMessage): ... def __init__(self, context, text): ... self._text= text ... self._context= context >>> class MyMessage2(MyMessage): ... def __init__(self, context, number): ... self._text= str(number * 42) ... self._context= context >>> class MyMessageTypes(IntDescriptor): ... message1= auto() ... message2= auto() >>> class MyMessageBuilder(GenericBuilder): ... def init_hook(self): ... self.set_fixed_args(context= \"foobar\") >>> message_provider= Factory() >>> message1_builder= MyMessageBuilder(MyMessageTypes.message1, MyMessage1) >>> message2_builder= MyMessageBuilder(MyMessageTypes.message2, MyMessage2) >>> message_provider.register_builder(message1_builder) >>> message_provider.register_builder(message2_builder) >>> message1= message_provider(MyMessageTypes.message1, text= \"johndoe\") >>> message2= message_provider(MyMessageTypes.message2, number= 42) >>> print(message1) foobar: johndoe >>> print(message2) foobar: 1764 ``` \"\"\" if builder_type is None : raise ValueError ( f ' { self . __class__ . __name__ } : builder_type cannot be None.' ) if not isinstance ( builder_type , GenericBuilder ) and type_descriptor_key is None : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key cannot be None, if builder_type is not an instance of GenericBuilder.' ) if not isinstance ( builder_type , GenericBuilder ) and artifact_type is None : raise ValueError ( f ' { self . __class__ . __name__ } : artifact_type cannot be None, if builder_type is not an instance of GenericBuilder.' ) if type_descriptor_key is not None and type_descriptor_key in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : type_descriptor_key { type_descriptor_key } already registered to build { self . _builder_registry [ type_descriptor_key ] } .' ) if isinstance ( builder_type , GenericBuilder ): for type_descriptor_key in builder_type . _registry . keys (): if type_descriptor_key in self . _builder_registry : raise ValueError ( f ' { self . __class__ . __name__ } : trying to register builder \\' { builder_type } \\' , but type_descriptor_key { type_descriptor_key } already registered in factory to build { self . _builder_registry [ type_descriptor_key ] } .' ) else : self . _builder_registry [ type_descriptor_key ] = builder_type else : self . _builder_registry [ type_descriptor_key ] = builder_type ( type_descriptor_key , artifact_type )","title":"register_builder()"},{"location":"usage/settings/","text":"Application settings management \ud83d\udd17","title":"Settings Management"},{"location":"usage/settings/#application-settings-management","text":"","title":"Application settings management"}]}